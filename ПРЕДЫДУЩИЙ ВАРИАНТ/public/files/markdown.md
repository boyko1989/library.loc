# Изучение Web-разработки.

## 06.07.2020

---

#### Тема: "Функция _header_ в PHP".

_Видеокурс: "PHP-Мастер". Бонусный блок №1, видео №16._

---

Описание:

```php
void header( string $string [,bool $replace = true [, int $http_response_code ]] )
```

header() используется для отправки HTTP заголовка.

HTTP заголовки отправляет сервер и они нужны браузеру для того, чтобы он мог корректно отобразить страницу.

Если в браузере на интересуемой странице открыть консоль на вкладке *"Сеть"*, то можно увидеть ответ от сервера в колонке *"Статус"* (например 200 или 404), а есди мы кликнем по строке, то сможем увидеть заголовки. Нас интересуют заголовки ответа, например ***Content-Type***, то есть тип документа. Если вместо *text/html* будет *text/plane*, то браузер отобразит HTML-код страницы.

К практике использования функции ***header***. Чаще эту функцию используют для установления кодировки.

```php
<?php
header('Content-Type: text/html; charset=utf8');
?>
<!DOCTYPE html>
<html lang="en">
<head>
	<title>Dociment</title>
</head>
<body>

	привет, мир!

</body>
</html>
```

Во вкладке _"Сеть"_ будет такая запись в заголовках ответов:

```
Content-Type: text/html; charset=utf8
```

Даже, если мы добавим в html такой тег:

```html
<meta charset="windows-1251" />
```

то браузер его проигнорирует, так как приоритет ***header*** выше тегов html.

> Практический вывод такой - если ломается кодировка в html файле, добавляем

```html
<meta charset="utf8" />
```

> Если в PHP, то

```php
<?php
header('Content-Type: text/html; charset=utf8');
```

---

В этом видео автор объясняет также, работу с кодировкой в файле ***.htaccess***

---

##### Редирект

Редирект — перенаправление пользователя с одной страницы на другую (с одного URL на другой). Редиректы могут перенаправлять посетителей как на страницы того же сайта, так и на страницы другого сайта.

Для этого тоже можно использовать функцию ***header***. Например, после успешной авторизации пользователя, мы можем перебросить его на какую-нибудь страничку.

Редирект можно сделать двумя командами:

1. `Location: [адрес]` В итоге получаем 302 редирект. Редирект происходит не сразу - сначала выполняется первоначальная страница. Это не всегда нужно, а иногда и вредно (если на странице есть код, который войдёт в конфликт). Нужно его как-то остановить. Сделать это позволяют две функции ***die*** и ***exit***.

2. `refresh: [секунды]; url=[адрес]` Этот способ позволяет выполнить весь код на странице, а потом уже перейти (спустя определённое количество секунд на другую страницу).

Код (inc.php - это файл, в котором одна строка: "_Привет из подключаемого файла_"):

```php
<?php
header('Content-Type: text/html; charset=utf8');
//header('Location: inc.php');
header('refresh: 5; url=inc.php');
//exit;
die;
?>

<!DOCTYPE html>
<html lang="en">
<head>
	<title>Dociment</title>
</head>
<body>

	привет, мир!

</body>
</html>
```

Нужно обратить внимание на то, что перед функцией **_header_** не должно стоять никакого вывода. Поскольку браузер должен проанализировать заголовки и в соответствии с ними показать нашу страницу. И ещё, заголовки нельзя отправлять больше одного раза.

Стоит обратить внимание, что пустая строка в начале php-файла тоже является выводом.

К вопросу о том, как использовать функцию **_header_**, если нужно отправить какой-нибудь дугой код ответа, например 404. Впринципе оформить страницу - не составляет особого труда. Проблема в том, что поисковые роботы при отсутствии страницы должны отработать 404 ответ. А если пользователь получает какую-либо страницу, то сервер возвращает код 200.

```php
header('HTTP/1.0 404 Not Found');
```

В статусе _загруженной_ страницы видим 404 ответ!

Точно также можно отправлять и другие коды, например _304 Not Modified_. Этот код говорит о том, что страница со времени своего последнего ответа не изменялась, а, соответственно, браузер может взять её из своего кэша. Как это проверить?

Например можно что-нибудь сейчас добавить в код. И при обновлении страницы, мы не увидим изменений. Папка с кешем на большом компьютере: C:\Documents and Settings\L_Boyko\AppData\Local\Mozilla\Firefox\Profiles\4flc3wdg.dev-edition-default\cache2\entries . Это нужно в первую очередь для снижения нагрузки на сервер и ускорения индексации страниц.

**Настроим скачивание.** Например, если хотим отдать PDF, это может выглядеть как-то так:

```php
<?php
// Будем передавать PDF
header('Content-Type: application/pdf');

// Он будет называться downloaded.pdf
header('Content-Disposition: attachment; filename="downloaded.pdf"');

// Исходный PDF-файл original.pdf
readfile('original.pdf');
?>
```

Content-Type можно определить из списка MIME-типов.

Я сделал следующее:

1. В корень сайта поместил брошюру про регулярные выражения
2. Переименовал файл в _"regexp.pdf"_
3. Написал следующий код:
   ```php
    <?php
        header('Content-Type: application/pdf');
        header('Content-Disposition: attachment; filename="regexp.pdf"');
        readfile('regexp.pdf');
    ?>
   ```
4. Сохранил и скачал с локального сервера
5. Попробовал закинуть файл в папку, но он скачаивался битым.
6. Проверил на реальном хостинге - всё работает.

Для закрепления материала я сделал редирект на страницу скачивания. Страница - это скрипт _link.php_. Код _index.php_:

```php
<?php
    header('Content-Type: text/html; charset=utf8');
    header('refresh: 5; url=content/link.php');
?>
```

Код _link.php_:

```php
<?php
    header('Content-Type: application/pdf');
    header('Content-Disposition: attachment; filename="/content/regexp.pdf"');
    readfile('regexp.pdf');
?>
```

Соответственно файл я переместил в папку _content_ и туда же _link.php_.

Перейду сразу с этих двух видео на _№24_.

---

#### Тема: "Загрузка файлов в PHP".

---

Я знаком с методами _POST_ и _GET_ - конечно, я ещё раз просмотрю эти темы:

- Функции для работы со строками
- Функции даты и времени
- Методы _POST_ и _GET_

Но пока меня интересуют следующие три темы:

- Загрузка файлов в PHP
- Работа с сессиями в PHP
- Работа с куками в PHP

Это уже достаточно серьёзные темы и пройдя их, я без труда смогу восполнить пробелы в первых трёх, да и других темах, которые автор не стал рассматривать (_см. [мануал](https://yadi.sk/d/NtKXWl5u7Bj_TA)_)

---

**!\*** Как известно, все методы передачи данных по-сути массивы (а ещё их называют суперглобальными переменными)

Так вот суперглобальная переменная для этой нашей темы - _\$\_FILES_. В [мануале](https://yadi.sk/d/NtKXWl5u7Bj_TA) в разделе "Отличительные особенности → Загрузка файлов на сервер" есть очень много инфорамации на эту тему.

Чтобы загрузить файл нам нужно создать в HTML input type="file" именно этот инпут позволяет прикреплять файл к полю формы. Дадим ему имя, с которым дальше будем работать, например _'file'_

```php
<?php
error_reporting(-1);

if(isset($_POST['send'])) {
	echo '<pre>';
	print_r($_POST);
	echo '<pre>';
}

?>
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<form method="post" action="" enctype="multipart/form-data">
		<p>
			<input type="text" name="name">
		</p>
		<p>
			<textarea name="text"></textarea>
		</p>
		<p>
			<input type="file" name="file">
		</p>
		<p>
			<button type="submit" name="send" value="test">Send</button>
		</p>
	</form>
	<hr>
</body>
</html>
```

Нам нужны далеко не все поля - некоторые приведены для повторения. По-большому счёту нам потребуются строки примерно с .

Через этот инпут мы будем прикреплять файлы, но чтобы форма могла отправлять файлы, мы должны дописать для неё соответствующий атрибут (в 19 строке) _enctype="multipart/form-data"_.

Но сейчас мы не сможеп при отправке картинки, нaпример, увидеть её в описанном массиве - нам нужен _\$\_FILES_

Опишем его, сохраним файл и посмотрим результат:

```php
if( !empty($_FILES) ){
	echo '<pre>';
	print_r($_FILES);
	echo '<pre>';
}
```

```
Array
(
    [file] => Array
        (
            [name] => 1.jpg
            [type] => image/jpeg
            [tmp_name] => D:\OpenServer\userdata\php_upload\php4330.tmp
            [error] => 0
            [size] => 44658
        )

)
```

Описание выглядит так, чтобы нам не выводился пустой массив в одну строку.

По индексу _file_ - то, что мы указали в имени инпута - мы видим ещё один массив (то есть мы получаем многомергый массив).

- [name] - первоначальное имя файла
- [type] - MIME-тип файла
- [tmp_name] - путь к временному файлу на сервере. Отсюда мы можем его забрать и переместит ьв нужную папку. Если мы этого не делаем, PHP сам его удаляет. Сюда же складываются и файлы сессий.
- [error] - ошибки. Значение кодов смотри [здесь](https://www.php.net/manual/ru/features.file-upload.errors.php)
- [size] - размер в байтах.

Теперь загружаем этот файл в нужную папку. Для начала создадим её в корне сайта (назову её _upload_).

Чтобы поместить папку в нужное место, есть фукция **_move_uploaded_file_** ([manual](https://www.php.net/manual/ru/function.move-uploaded-file.php)).

В конце концов получен такой код:

```php
<?php
error_reporting(-1);

if(isset($_POST['send'])) {
	echo '<pre>';
	print_r($_POST);
	echo '<pre>';
}

if( !empty($_FILES) ){
	echo '<pre>';
	print_r($_FILES);
	echo '<pre>';
	move_uploaded_file($_FILES['file']['tmp_name'], 'upload/' . $_FILES['file']['name']);
}

?>

<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<form method="post" action="" enctype="multipart/form-data">
		<p>
			<input type="text" name="name">
		</p>
		<p>
			<textarea name="text"></textarea>
		</p>
		<p>
			<input type="file" name="file">
		</p>
		<p>
			<button type="submit" name="send" value="test">Send</button>
		</p>
	</form>
	<hr>
</body>
</html>
```

---

#### Тема: "Работа с сессиями в PHP".

---

[МАНУАЛ](https://www.php.net/manual/ru/intro.session.php)

Сессии - это очень поолезная возможность PHP, которая позволяет передавать данные между страницами. Если мы в массив **_\$\_SESSION_** запишем какие-то данные, то во время работы с сайтом нам эти данные будут доступны на любой странице сайта на протяжении любого сеанса.

Рассмотрим функции

- session_start
- session_unset
- session_destroy
- session_id
- session_name

Функция **_session_start_** - это та функция, которую мы должны выполнить перед тем, как работать с сессией.

Физически сессия - это файл, который хранится во временной папке и все те данные, которые мы сохраняем в сессию записываются там. Соответственно, когда мы запускаем функцию **_session_start_**, она создаёт этот файл или обращается к нему, если он уже был создан ранее.

Если предположить, что один и тот же человек открывает сайт с двух разных браузеров, то под каждый из них открывается свой файл сессии. Эти файлы не пересекаются и доступ к этим файлам имеет только определённый клиент. Это значит, что можно организовать авторизацию.

А как понять, что именно данный файл относится к данному клиенту? Делается это посредством куков. Эти файлы храняться на стороне клиента и в эти файлы мы тоже можем записать какие-то данные. Файл куки имеет определённый идентификатор, который совпадает с идентификатором файла, лежащего на сервере. Когда мы запускаем **_session_start_**, она проверяет есть ли этот идентификатор у клиента, и если он есть, ищется соответствующий файл на сервере и тогда сессия будет работать для каждого клиента, а если нет, то под него открывается новая сессия.

---

Создадим простое приложение с секретной страницей. Делаем три файла:

- secret.php
- sess1.php
- sess2.php

Перейдём в sess1.php и запишем

```php
session_start();
```

Мы знаем, где на OpenServer хранятся файлы сессий:
~userdata\temp

При обновлении страницы в консоли в разделе "Storage" можно увидеть новую куку _PHPSESSID_, а в указаной немного выше дирректории появляется файл, у меня это _"sess_avp4t82jgcsfc6tfie2cb5978tk6vgpd"_ и оно совпадает со значением куки.

Стоит учитывать, что функция **_session_start_** как и функция **_header_** чувствительна к выводу.

Поскольку переменная \$\_SESSION - это массив, то и записать туда можно что угодно, например своё имя.

```php
<?php

session_start();

$_SESSION['name'] = 'Андрей';
echo $_SESSION['name'];
?>
```

В файле сесси после обновления страницы появилась такая информация:

```
name|s:12:"Андрей";
```

Соответственно "name" - это ключ, "s:12" - это длина строки в байтах и содержимое. Это сериализованная строка.

Если закоментировать строку с добавлением данных к сессии, то при обновлении страницы мы всё равно увидим введённое ранее значение. В другом же браузере будет создан свой файл сессии и при отображении нашего скрипта, выведется пустая страница.

Во втором файле sess2.php напишем тот же код, только имя введём "Павел".

Если нам что-то нужно удалить, то можно воспользоваться функцией _unset_:

```php
nset ($_SESSION['name']);
```

Если нужно удалить весь массив, то можно воспользоваться функцией **_session_unset_**.

Функция **_session_destroy_** полностью удаляет файл сессии, хотя в строке куков в консоли он ещё значится, и, если закоментировать строку с функцией и обновить страницу, он воссоздастся.

```php
<?php

session_start();

$_SESSION['name'] = 'Павел';
$_SESSION['name2'] = 'Андрей';
$_SESSION['login'] = 'JagerB';

//unset ($_SESSION['name']);

session_unset();

echo '<pre>';
var_dump ($_SESSION);
echo '<pre>';

session_destroy();

?>
```

Для практики создадим прилложение для доступа к определённой странице.

Создадим простейшее меню:

> Вводим в VSC ul>li\*3 и получаем:
> `<ul></ul>`

    `<li></li>`
    `<li></li>`
    `<li></li>`

`</ul>` - последовательность для ввода списка

Как ограничить доступ к "_secret_"? Пусть у нас авторизация будет только по логину. Т.е. если мы правильно вводим логин, то мы запишем в сессию какой-либо элемент, например _\$\_SESSION['admin']_. Соответственно этот элемент у нас будет только в том случае, если мы успешно авторизовались. На странице _secret.php_ мы можем организовать простейшее условие: если у нас существует такой элемент, тогда мы считаем пользователя авторизованным, в противном случае мы прекращаем дальнейшую работу.

```php
<?php
# secret.php
session_start();
if( !isset($_SESSION['admin']) ) die('Вас тут не стояло!');
    echo "Моё Вам здрасти, {$_SESSION['admin']}!";
?>

<ul>
    <li><a href="sess1.php">sess1</a></li>
    <li><a href="sess2.php">sess2</a></li>
    <li><a href="secret.php">secret</a></li>
</ul>
```

Работает! Ни меню, никаких приглашений больше нет. Создадим форму авторизации.

```html
<hr />

<form action="" method="post">
  <input type="text" name="login" />
  <button type="submit">Войдитя</button>
</form>
```

Теперь сделаем процедуру её обрабоки:

Если получили из формы какое-то значение и оно соответствует константе _ADMIN_, то мы записываем в массив сессии в ключ _admin_ эту константу и пишем "Вы успешно авторизовались!". В противном случае, пишем "Неверный ввод" и ждём следующего ввода.

```php
define('ADMIN', 'admin');

if (!empty($_POST['login'])){
    if($_POST['login'] === ADMIN) {
        $_SESSION['admin'] = ADMIN;
        echo 'Вы успешно авторизовались!';
    } else {
        echo 'Неверный ввод';
    }
}
```

Однако, у нас возникла проблема F5. Чтобы отнеё избавиться, нужно перезапросить страницу. Чтобы это сделать средствами PHP, фактически нужно сделать редирект. Только в таком случае у нас не выведутся сообщения о успехе авторизации. Однако мы можем и эти сообщения записать в сессию в один ключ и вывести после цикла. А редирект установить после всех первоначальных проверок.

Чтобы сообщение не висело постоянно, мы воспользуемся функцией _unset()_

```php
<?php
# sess1.php
session_start();
define('ADMIN', 'admin');

if (!empty($_POST['login'])){
    if($_POST['login'] === ADMIN) {
        $_SESSION['admin'] = ADMIN;
        $_SESSION['res'] = 'Вы успешно авторизовались!';
    } else {
        $_SESSION['res'] = 'Неверный ввод';
    }
    header("Location: sess1.php");
    die;
}
?>

<ul>
    <li><a href="sess1.php">sess1</a></li>
    <li><a href="sess2.php">sess2</a></li>
    <li><a href="secret.php">secret</a></li>
</ul>

<hr>

<?php
    if (isset($_SESSION['res'])){
		echo $_SESSION['res'];
		unset($_SESSION['res']);
    }

?>

<form action="" method="post">
    <input type="text" name="login">
    <button type="submit">Войдитя</button>
</form>
```

Предусмотрим ещё механизм выхода. Должна быть кнопка выхода, при нажатии на которую должен удаляться _\$\_SESSION['admin']_.

Допишем в secret.php ссылку, где GET-параметр _do=exit_. Это значит, что мы можем добавить условие: если у нас существует в массиве _\$\_GET_ элемент _"do"_ и при этом _do=exit_, то нужно удалить _\$\_SESSION['admin']_

```php
<?php
# secret.php
session_start();

if( isset($_GET['do']) && $_GET['do'] == 'exit' ) unset($_SESSION['admin']);

if( !isset($_SESSION['admin']) ) die('Вас тут не стояло!');
    echo "Моё Вам здрасти, {$_SESSION['admin']}!";
?>

<a href="secret.php?do=exit">Logout</a>

<ul>
    <li><a href="sess1.php">sess1</a></li>
    <li><a href="sess2.php">sess2</a></li>
    <li><a href="secret.php">secret</a></li>
</ul>
```

---

#### Тема: "Работа с куками в PHP".

---

Мы сталкивались с куками при изучении сессии. Кука, которая отвечает за сессию исчезает при её завершении. Но что, если нам нужно сохранить какую-то информацию на более длительный срок?

Напишем такой код:

```php
<?php

session_start();
$_SESSION['test'] = 123;
var_dump($_SESSION);
?>
```

Кука этой страницы будет действовать в течении одной сессии.

Более длительное применение кук испольуется при механизмах "Remember Me". На самом деле это не сервер запоминает клиента, а браузер. В куку записывается строчка, и эквивалентная записывается в базу данных. Когда клиент заходит вновь, строчки сравниваются и для клиента автоматически начинается сессия.

Но в куку можно записать что угодно. Подробнее [здесь](https://www.php.net/manual/ru/features.cookies.php).

Нас будет интересовать функция [_setcookie()_](https://www.php.net/manual/ru/function.setcookie.php).

```php
 setcookie ( string $name [, string $value = "" [, int $expires = 0 [, string $path = "" [, string $domain = "" [, bool $secure = FALSE [, bool $httponly = FALSE ]]]]]] ) : bool
```

Параметры:

- **_name_** - Название cookie.
- **_value_** - значение. Например у кук, которые создаются в связке с файлом сессии значение - это 32 значная часть имени файла сессии.
- **_expires_** - время истечения куки.
- **_path_** - Путь к директории на сервере, из которой будут доступны cookie. Об этом подробно будет рассказано ниже.
- **_domain_** - домен, которому доступны cookie.
- **_secure_** - http или https. Если "правда", то куки будут переданы на сервер только, если у нас https соединение.
- **_httponly_** - кука будет недоступна для Java Script. XSS-атаки.
- **_options_** - уточнить.

Куки чувствительны к выводу! Вывести куку можно, обратившись к соответствующему массиву.

Поэкспериментируем с куками. Код:

```php
<?php
setcookie('test', 'My_Value');
echo $_COOKIE['test'];
?>
```

Если запустим этот код, то в браузере ничего не выведется, но в консоли она будет видна. Чтобы в браузере что-то появилось, нужно обновить страницу.

Установим куку на большее количество времени. Используем функцию time() и прибавим такое количество секунд, которое должна "прожить" кука. Например:

```php
...
... , time()+3600); //установили на час
...
```

Куки видны со всех страниц сайта. Но нужно иметь в виду, что по умолчанию кука создаётся для той дирректории, в которой находится. Для неё и всех вложенных в неё папок. Для всех папок уровнем выше эта кука будет недоступна.

Если нужно сделать куку доступной для всего сайта, то необходимо использовать ещё один параметр - это параметр _path_. В описанном случае он должен иметь значение "/".

Как удадить куку? Указать ей время "жизни" меньше текущего.

Например:

```php
...
setcookie('test', time()-3600);
...
```

Попрактикуемся - создадим счётчик. Счётчик будет фиксировать сколько раз мы обновили страницу.

```php
isset($_COOKIE['counter']) ? setcookie('counter', ++$_COOKIE['counter'], time()+3600, '/') : setcookie('counter', 1, time()+3600, '/');
```

Почему тернарный оператор, потому что при первом обращении основное условие (нет такой куки), а потом нужно именно оно.

И вывод:

```php
echo isset($_COOKIE['counter']) ? $_COOKIE['counter'] : 1;
```

---

#### Тема: Функции для работы с файлами в PHP".

---

[Мануал](https://www.php.net/manual/ru/ref.filesystem.php)

##### **_copy_**

Берёт файл и копирует его по новому адресу.

```php
 copy ( string $source , string $dest [, resource $context ] ) : bool
```

- source - Путь к исходному файлу.

- dest - Путь к целевому файлу. Если dest является URL, то операция копирования может завершиться ошибкой, если обертка URL не поддерживает перезаписывание существующих файлов.

---

## 07.07.2020

---

Сегодня помимо чтения и мизерной практики по PHP, я поигрался с _Total Commander_ for Android. Во-первых, (в успехе чего я не сомневался), я установил FTP-соединение с хостингом и, во-вторых, узнав, что к Яндекс Диску можно подключиться по протоколу WebDav, я скачал плагин для программы и набрав имя, адрес (https://webdav.yandex.ru), логин и пароль от Яндекса и поставив галочку на "использовать SSL", я подключился к облаку через _Total Commander_. [Статья](http://e-webmaster.ru/ftp/yandeks-disk-ftp-kak-podklyuchitsya.html)

Дальше я пытался настроить синхронизацию некоторых папок через _Total_. Не могу сказать, что получилось хорошо - я настроил перекрёстные закладки на папки с одинаковым содержимым. Это книги и маркдаун. Что касается книг, то открывая их в одном и том же приложении, такое ощущение что открываешь один файл.

При работе с этими книгами на компьютере, я не вижу тех закладок, которые я сделал на устройстве. Тут у меня встал вопрос: а не разные ли они вообще сущности - закладки в программе _Read Era_ и в _PDF X Change_?

Это рассмотрим в другой раз, а сейчас я заметил, что тот файл, который я открывал в телефоне - это первоначальный файл, который имелся у меня до всех манипуляций: "_progintro_vol1.pdf_", а в папке "РАБОЧАЯ" на Яндексе у меня файл "_02 - Столяров(1) - Азы программирования.pdf_". Я создал на компьютере пробную закладку в последнем файле. Загрузив его на телефон через _webdav_, я увидел установленную закладку (правда в разделе "Оглавление"). Попробую наоборот, сделать закладку в телефоне. При замене файла на Яндексе, возникает ошибка и изменения с телефона не отражаются на сервере...

Я поробовал в _Total Commander_ даже через программу от Яндекса отправить этот файл, но безуспешно. Почему?

Попробую отредактировать оглавление через Read Era - это не возможно. Попробую использовать на компьютере другую программу для просмотра PDF. Попробую [Acrobat](https://get.adobe.com/ru/reader/)

Интересная ссылка на [обсуждение](https://qastack.ru/superuser/276311/how-to-import-export-and-edit-bookmarks-of-a-pdf-file) по этому поводу.

Здесь мне впринципе не удалось создать закладку, но я создал комментарий - посмотрим как он будет отображаться. Нет никакой реакции ни в _Read Era_, ни в _PDF X Change_.

Ну что ж, в итоге я тем не менее пока для обращений к Яндекс Диску с телефона буду пользоваться _Total Commander_. В нём у меня настроены перекрёстные закладки, которые отображаются на начальном экране этого приложения. Получается, нужно почитать и подредактировать на телефоне что-то - обращаешся к _Total Commander_ к папке на Диске. Берёшь файл, копируешь с заменой в телефон и работаешь с ним. После работы, обращаешся к _Total Commander_ к папке на телефоне и копируешь с заменой на Диск. Как раз, чтобы не искать пострянно пути и настроены закладки. По-хорошему, нужно одной кнопкой синхронизировать изменения, но пока я не совсем понял как это делается. Но разберёмся!

---

## 09.07.2020

---

#### Тема: "Функции для работы со строками".

---

Ссылки на мануал [первая](https://www.php.net/manual/ru/ref.strings.php) и [вторая](https://www.php.net/manual/ru/ref.mbstring.php)

Строковых функций больше, чем функций для работы с массивами. Причина в том, что строки - это наиболее распространённый тип элементов, с которыми приходится иметь дело. Нужно периодически проходится по списку функций, чтобы в голове откладывалось их описание.

Начнём!

Функция **_explode_**:

- Назначение: из строки формирует массив.
- Принимает три параметра:
  - Разделитель
  - Строка
  - То, на сколько частей делится наша строка.

Например у нас есть строка:

```php
$str = 'Иванов Иван Иванович';
```

Нам нужно из этой строки получить отдельно имя, отдельно фамилию и отдельно отчество.

```php
...
$str = 'Иванов Иван Иванович';
$data = explode(' ', $str);
print_r($data);
...
```

Как видим, была создана переменная-массив, которая значением имеет вывод функции **_explpode_**.

Если нужно вывети часть полученного массива, тогда

```php
...
echo $data[0];//выыедет фамилию
...
```

Третий параметр позволяет ограничить количество элементов массива.

---

Функция: **_implode_**

- Назначение: из массива формирует строку.
- Принимает два параметра:
  - Разделитель
  - Массив

```php
...
$data = ['Иванов', 'Иван', 'Иванович'];
echo $str = implode(' ', $data);
...
```

---

Функция: **_trim_**

- Назначение: удаление символов с начала строки или с конца. (Чаще всего - пробелы)
- Принимает два параметра:
  - Строка
  - Символы, которые хотим удалить.

Например, код:

```php
...
$str = "<p>Hello</p>";
$str .= "<p>world!</p>";
echo $str;
...
```

Даёт такой результат:

```
Hello

world!
```

Но исходный код страницы говорит о том, что всё идёт в одну строку:

```
<p>Hello</p><p>world!</p>
```

Поэтому мы обрамляем наши строки символами переноса строки:

```php
...
$str = "\n<p>Hello</p>\n";
$str .= "\n<p>world!</p>\n";
echo $str;
...
```

На странице не произошло изменений, но в исходном коде - всё как надо:

```

<p>Hello</p>

<p>world!</p>

```

Однако здесь появидись лишние переносы строк, которые мы можем удалить этой функцией.

```php
echo trim($str);
```

```
<p>Hello</p>

<p>world!</p>
```

Эта функция применяется, например при обработке форм - пользователи нередко втыкают лишние пробелы куда не следует. Мы же обрезаем их, защищая его и себя от лишней головной боли.

---

Функция: **_md5_** и **_sha1_**

- Назначение: хеширование паролей, например для хранения в базе данных
- Принимает два параметра:
  - Строка
  - .

Функции скомпроментированны, так как они уже давно используются и их научились взламывать. Тем более, что пользователди часто в качестве пароля используют слово из словаря. То есть хакер вполне может полученный хеш проверить через словарь декрипта **_md5_** и заполучить пароль.

---

Функция: **_nl2br_**

- Назначение: замена символа "новая строка" на тег \<br />
- Принимает параметр:
  - Строка

Это может быть полезно, если в нашем текстовом поле пользователь вводя какой-то текст пользуется символом переноса строки. В базу данных его запись попадает с этими символами.

Например, пользователь вводи эту вразу, надимая на каждом слове _enter_:

```php
$str = "Hello\nworld\n";
echo $str;
```

В браузере у нас получается:

```
Hello world
```

В исходном коде:

```
Hello
world

```

Чтобы получилось то, что ожидает пользователь, нужно использовать эту функцию:

```php
$str = "Hello\nworld\n";
echo nl2br($str);
```

---

Функция: **_str_replace_**

- Назначение: замена символа "новая строка" на тег \<br />
- Принимает 3+1 параметра:
  - Искомое
  - На что заменить
  - Строка

Например, мы хотим обработать коментарий пользователя, чтобы заменить, например, мат на звёздочки. Ну или предположим, у нас на сайте есть bb теги. Нам нужно, чтобы наш код транслировал их в обычный HTML код.

```php
$str = 'Привет! Меня зовут [b]Вася![/b]';
echo $str;
```

Браузер:

```
Привет! Меня зовут [b]Вася![/b]
```

Воспользуемся функцией:

```php
$str = 'Привет! Меня зовут [b]Вася![/b]';
$str = str_replace('[b]', '<b>', $str);
$str = str_replace('[/b]', '</b>', $str);
echo $str;
```

Браузер:

> Привет! Меня зовут <b>Вася!</b>

Однако, это слишком примитивно, так как bb тегов домтаточно много и постоянно вызывать функцию нерационально. Эта функция может работать и с массивом:

```php
$str = '[i]Привет![/i] Меня зовут [b]Вася![/b]';
$search = ['[b]','[/b]','[i]','[/i]'];
$replace = ['<b>','</b>','<i>','</i>'];
$str = str_replace($search, $replace, $str);
echo $str;
```

Но и это ещё не всё!

Предположим пользователь напортачил в регистром в bb тегах. Вместо этой функции можно использовать функцию **_str_ireplace_**, которая работает без учёта регистра.

---

Функция: **_strip_tags_**

- Назначение: вырезает html теги.
- Принимает 1+1 параметра:
  - Строка

Для примера возьмём исходный код:

```php
$str = '<i>Привет!</i> Меня зовут <b>Вася!</b>';
echo $str;
```

В браузере получим:

> _Привет!_ Меня зовут **Вася!**

Представим, что мы получили эту строку от пользователя, который может записать и вредоносный код. Например:

```php
$str = '<i>Привет!</i> Меня зовут <b>Вася!</b> <script>alert("XSS")</script>';
echo $str;
```

Если мы никак не отработаем то, что пользователи вводят в поле коментариев, то омжет произойти что угодно. Например, кто-то может своровать куки пользователей, а это уже серьёзный вопрос безопасности.

Эта функция вырезает все HTML теги безразбора. Но можно задействовать второй параметр:

```php
$str = '<i>Привет!</i> Меня зовут <b>Вася!</b> <script>alert("XSS")</script>';
echo strip_tags($str, '<b><i>');
```

---

Функция: **_strlen_**

- Назначение: считает количество байт в строке.
- Принимает 1 параметр:
  - Строка

Не путать количество байт и количество символов.

Например кириллическая кодировка utf-8 - 2 байта на символ. Для корректоного подсчёта символов, следует использовать многобайтную функцию **_mb_strlen_**

---

Функция: **_strpos_**

- Назначение: Возвращает позицию первого вхождения подстроки.
- Принимает 2+1 параметра:
  - Строка в которой производится поисковые
  - То, что мы ищем в первом параметре
  - Смещение относительно начала строки (отсчёт с нуля)

```php
$str = 'Привет, мир!';
echo mb_strpos($str, 'и', 0, 'utf-8');
```

Логично использовать в условиях: если присутствует какой-то цикл в строке, тогда одни действия, если нет, то другие.

Однако, нужно не забывать про особенности приведения целочисленного типа к булевому. Если мы в вышенаписаной фразе найдём букву "П", то функция вернёт "0" , то есть "FALSE" по-булевски.

В этом случае мы должны явно проверить, что функция возвращает "TRUE", либо "FALSE". Для того нужно использовать строгое сравнение "==".

```php
$str = 'Привет, мир!';
if(mb_strpos($str, 'П', 0, 'utf-8') !== false) echo 'OK';
else echo 'NO';
```

---

Функция: **_strtolower_** **_strtouper_**

- Назначение: приводит строку к нижнему и верхнему регистрам соответственно.
- Принимает 2 параметра:
  - Строка
  - Кодировка

```php
$str = 'привет, мир!';
$str2 = 'ПРИВЕТ, МИР!';

echo mb_strtoupper($str, 'utf-8');
echo mb_strtolower($str2, 'utf-8');
```

---

Функция: **_substr_**

- Назначение: если нужно из строки получить подстроку.
- Принимает 2+2 параметра:
  - Строка
  - С какой позиции начинаем брать символы
  - До какой позиции берём
  - Кодировка

Допустим, из фразы "привет, мир!" нам нужно взять только слово мир:

```php
$str = 'привет, мир!';
echo mb_substr($str, 8, null, 'utf-8');
```

Браузер:

```
мир!
```

Если, например, нужно отрезать восклицательный знак, тогда просто укажем, сколько символов брать:

```php
$str = 'привет, мир!';
echo mb_substr($str, 8, 3, 'utf-8');
```

---

Функция: **_htmlspecialchars_**

- Назначение: теги никуда не деваются, но в тоже время они не отрабатывают.
- Принимает 1+2 параметра:
  - Строка
  - Флаги (расширяют функционал)

Существует правило, что всё то, что набирает пользователь, должно сохраняться в базе данных, так как написал пользователь. Естесственно выводить мы должны как положено по соображениям безопасности. Функция **_striptags_** начисто вырезает все неуказанные теги, поэтому она не годится в свете вышеозначенного правила.

**_htmlspecialchars_** же делает так, что теги никуда не деваются, но в тоже время они не отрабатывают. Она простро превращает спецсимволы в HTML-сущности, то есть символы, кторыми кодируются синтаксические составляющие.

Например, у нас есть Вася, который в комментариях решил немного похулиганить и записал такой код (эквивалентно):

```php
//$str = '<h1><i>Привет!</i> Меня зовут <b>Вася!</b></h1><iframe src="https://docs.microsoft.com/"></iframe>';
$str = '<h1><i>Привет!</i> Меня зовут <b>Вася!</b></h1><iframe src="https://docs.microsoft.com/" height="100%" width="100%"></iframe><script>alert(\'Админ - лох!!!\')</script>';
echo $str;
```

Используем эту функцию:

```php
echo htmlspecialchars($str);
```

Браузер:

```
<h1><i>Привет!</i> Меня зовут <b>Вася!</b></h1><iframe src="https://docs.microsoft.com/" height="100%" width="100%"></iframe><script>alert('Админ - лох!!!')</script>
```

Исходный код:

```
&lt;h1&gt;&lt;i&gt;Привет!&lt;/i&gt; Меня зовут &lt;b&gt;Вася!&lt;/b&gt;&lt;/h1&gt;&lt;iframe src=&quot;https://docs.microsoft.com/&quot; height=&quot;100%&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;script&gt;alert('Админ - лох!!!')&lt;/script&gt;
```

---

Функция: **_htmlspecialchars_decode_**

- Назначение: напротив, преобразует сущности в код.
- Принимает 1+2 параметра:
  - Строка
  - Флаги (расширяют функционал)

```php
$str = '&lt;h1&gt;&lt;i&gt;Привет!&lt;/i&gt; Меня зовут &lt;b&gt;Вася!&lt;/b&gt;&lt;/h1&gt;&lt;iframe src=&quot;https://docs.microsoft.com/&quot; height=&quot;100%&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;script&gt;alert(\'Админ - лох!!!\')&lt;/script&gt;';

echo htmlspecialchars_decode($str);
```

В браузере выведет всё то, против чего мы в прошлом пункте боролись.

---

Функция: **_htmlentities_**

- Назначение: преобразует **абсолютно** весь код в сущности.

Альтернатива **_htmlspecialchars_**

---

---

## 09.07.2020

---

#### Тема: "Функции для работы с массивами".

---

В этом видео полезная часть по теме начинается с 10 минуты.

---

Функция: **_count_**

- Назначение: подсчитывает количество элементов массива или что-то в объекте.
- Параметры (1+1):
  - Массив
  - **OUNT_RECURSIVE** (или 1), **count()** будет рекурсивно подсчитывать количество элементов массива. В многомерных массивах.

```php
$arr = array('Иванов', 'Петров', 'Сидоров');

$goods = [
    [
        'title' => 'Nokia',
        'prise' => 100,
        'description' => 'Description'
    ],
    [
        'title' => 'iPad',
        'price' => 200,
        'description' => 'Description'
    ],
];

//echo count($arr);
echo count($goods, 1);
```

---

Функция: **_array_diff_**

- Назначение: находит отличия одного массива от другого.
- Параметры (min 2):
  - Массив исходный
  - Массив сравниваемый
  - ...

```php
$array1 = array("a" => "green", "red", "blue", "red");
$array2 = array("b" => "green", "yellow", "red");
$result = array_diff($array1, $array2);

echo "<pre>";
print_r($result);
echo "</pre>";
```

---

Функция: **_array_intersect_**

- Назначение: находит сходие элементы массивов.
- Параметры (min 2):
  - Массив исходный
  - Массив сравниваемый
  - ...

```php
$array1 = array("a" => "green", "red", "blue", "red");
$array2 = array("b" => "green", "yellow", "red");
$result = array_intersect($array1, $array2);

echo "<pre>";
print_r($result);
echo "</pre>";
```

---

Функция: **_array_key_exists_**

- Назначение: проверяет, присутствует ли в массиве указанный ключ или индекс:
- Параметры (2):
  - Проверяемое значени
  - Массив проверяемый

```php
$search_array = array('first' => 1, 'second' => 4);
if (array_key_exists('first', $search_array)) {
    echo "Массив содержит элемент 'first'.";
}
```

---

Функция: **_array_keys_**

- Назначение: возвращает все или некоторое подмножество ключей массива:
- Параметры (2+1):

  - Массив проверяемый
  - Проверяемое значение

```php
$arr = array('Иванов', 'Петров', 'Сидоров');

$goods = [
    [
        'title' => 'Nokia',
        'prise' => 100,
        'description' => 'Description'
    ],
    [
        'title' => 'iPad',
        'price' => 200,
        'description' => 'Description'
    ],
];

$result = array_keys($goods[1]);

echo "<pre>";
print_r($result);
echo "</pre>";
```

---

Функция: **_array_values_**

- Назначение: возвращает массив со всеми элементами массива:
- Параметры (1):

  - Массив

```php
$arr = array('Иванов', 'Петров', 'Сидоров');

$goods = [
    [
        'title' => 'Nokia',
        'prise' => 100,
        'description' => 'Description'
    ],
    [
        'title' => 'iPad',
        'price' => 200,
        'description' => 'Description'
    ],
];

$result = array_values($goods[1]);

echo "<pre>";
print_r($result);
echo "</pre>";
```

---

Функция: **_array_merge_**

- Назначение: Сливает один или большее количество массивов:

---

Функция: **_array_rand_**

- Назначение: выбирает одно или несколько случайных значений из массива
- Параметры:
  - Массив
  - Количество значений

---

Функция: **_array_reverse_**

- Назначение: возвращает массив с элементами в обратном порядке
- Параметры:
  - Массив
  - true - ключи будут сохраненины

Вобщем, что хочу сказать - неделя была очень очень очень жаркая. Поэтому никакого плана я не смог придерживаться до конца. Поэтому было разрозненное чтение на разные темы: "Генераторы PHP", "Регулярные выражения", "Вещественые числа в двоичном выражении" и т.п. Некоторые практические вещи я попытался освоить, например Git/Github, Flexbox, Grid CSS. Также посмеотрел некоторые интервью с программистами и всё - выходные закончились.

http://ipmnet.ru/~sadilina/
